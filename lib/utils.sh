################################################################################
#
################################################################################

[ -z $__utils_sh ] || __utils_sh=0

# -----------------------------------------------------------------------------
# import modules
_moddir="$(dirname "$BASH_SOURCE")"
. "$_moddir/core.sh" || { echo "Failed to import core module!" 1>&2; exit 1; }
. "$_moddir/path.sh" || { echo "Failed to import path module!" 1>&2; exit 1; }

# ==============================================================================
# I/O
# ==============================================================================

# ------------------------------------------------------------------------------
# read subject IDs from text file
read_sublst()
{
  local ids=($(cat "$2" | cut -d' ' -f1 | cut -d, -f1 | cut -d# -f1))
  local num=${#ids[@]}
  if [ $num -gt 0 ]; then
    info "Read IDs of $num subjects"
  else
    error "Failed to read subject IDs from file $2"
  fi
  local "$1" && upvar $1 ${ids[@]}
}

# ==============================================================================
# auxiliary functions
# ==============================================================================

# ------------------------------------------------------------------------------
# copy executable and its dependencies
pack_executable()
{
  if [ ! -f "$bindir/$1" ]; then
    local path="$(which "$IRTK_DIR/bin/$1" 2> /dev/null)"
    [ -n "$path" ] || path="$(which   "$1" 2> /dev/null)"
    makedir "$bindir"
    cp -f "$path" "$bindir/" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      info  "  Copied executable $path"
    else
      error "  Failed to copy executable $path"
    fi
  fi
}

# ------------------------------------------------------------------------------
# write common configuration of HTCondor job description, i.e., universe,
# executable, environment, and requirements to new file
make_sub_script()
{
  local node=
  local universe=vanilla
  local executable=
  while [ $# -gt 0 ]; do
    case "$1" in
      -universe)   optarg universe   $1 "$2"; shift; ;;
      -executable) optarg executable $1 "$2"; shift; ;;
      --)          shift; break; ;;
      -*)          error "make_sub_script: invalid option: $1"; ;;
      *)           [ -z "$node" ] || error "make_sub_script: too many arguments"
                   node="$1"; ;;
    esac
    shift
  done
  [ -n "$node"       ] || error "make_sub_script: missing name argument"
  [ -n "$executable" ] || error "make_sub_script: missing -executable argument"
  pack_executable "$executable"
  makedir "$(dirname "$node")"
  cat --<<EOF > "$node"
universe     = $universe
environment  = LD_LIBRARY_PATH=$topdir/$libdir:$LIBRARY_PATH
initialdir   = $topdir
executable   = $topdir/$bindir/$executable
log          = $topdir/$log
notify_user  = $notify_user
notification = $notification
requirements = $requirements
EOF
}

# ------------------------------------------------------------------------------
# write PRE script of HTCondor DAGMan node
make_pre_script()
{
  [ $# -eq 1 ] || error "make_pre_script: invalid number of arguments"
  makedir "$(dirname "$1")"
  cat --<<EOF > "$1"
#! /bin/bash
cd "$topdir" || exit 1
EOF
  chmod +x "$1" || exit 1
}

# ==============================================================================
# dag
# ==============================================================================

_dags=()
_dagdir=
_dagfile=

# ------------------------------------------------------------------------------
begin_dag()
{
  local node=
  local parent=()

  while [ $# -gt 0 ]; do
    case "$1" in
      -parent) optargs parent "$@"; shift ${#parent[@]}; ;;
      -*)      error "begin_dag: invalid option: $1"; ;;
      *)       [ -z "$node" ] || error "begin_dag: too many arguments"
               node=$1; ;;
    esac
    shift
  done
  [ -n "$node" ] || error "begin_dag: missing name argument"

  [ -n "$_dagdir"  ] || _dagdir="$dagdir"
  if [ -n "$_dagfile" ]; then
    append "$_dagfile" "\nSUBDAG EXTERNAL $node $topdir/$_dagdir/$node.dag\n"
    add_edge $node ${parent[@]}
  fi
  _dags=(${_dags[@]} $node)
  _dagfile="$_dagdir/$node.dag"
  _dagdir="$_dagdir/$node"
  write "$_dagfile" "# HTCondor DAGMan description file generated by\n# $appdir/$appname\n"
}

# ------------------------------------------------------------------------------
add_edge()
{
  [ $# -gt 0 ] || error "add_edge: invalid number of arguments"
  local child=$1
  shift
  [ $# -eq 0 ] || append "$_dagfile" "PARENT $@ CHILD $child\n"
}

# ------------------------------------------------------------------------------
end_dag()
{
  [ $#           -eq 0 ] || error "end_dag: invalid number of arguments"
  [ ${#_dags[@]} -gt 0 ] || error "end_dag: called more often than begin_dag"
  unset _dags[${#_dags[@]}-1]
  if [ ${#_dags[@]} -gt 0 ]; then
    _dagdir="$(dirname "$_dagdir")"
    _dagfile="$(dirname "$_dagdir")/${_dags[${#_dags[@]}-1]}.dag"
  else
    _dagdir="$dagdir"
    _dagfile=
  fi
}

# ------------------------------------------------------------------------------
# write DAGMan node scripts
add_node()
{
  [ $# -eq 2 ] || error "add_node: invalid number of arguments"
  make_pre_script "$_dagdir/$1.pre"
  make_sub_script "$_dagdir/$1.sub" -executable "$2"
  append "$_dagfile" "\nJOB $1 $topdir/$_dagdir/$1.sub\nSCRIPT PRE $1 $topdir/$_dagdir/$1.pre\n"
  append_node $1
}

# ------------------------------------------------------------------------------
# append DAGMan node scripts
append_node()
{
  [ $# -eq 1  ] || error "append_node: invalid number of arguments"
  [ -z "$pre" ] || append "$_dagdir/$1.pre" "$pre\n"
  [ -z "$sub" ] || append "$_dagdir/$1.sub" "$sub\n"
  pre=''
  sub=''
}

# ==============================================================================
# IRTK nodes
# ==============================================================================

# ------------------------------------------------------------------------------
# add node for pairwise image registration
ireg_node()
{
  local node=
  local parent=()
  local ids=
  local model=
  local energy='SIM[Similarity](I1, I2 o T)'
  local similarity='NMI'
  local hdrdofs=
  local dofins=
  local dofdir=
  local params=''
  local padding=-32767

  while [ $# -gt 0 ]; do
    case "$1" in
      -parent)             optargs parent    "$@"; shift ${#parent[@]}; ;;
      -subjects)           optargs ids       "$@"; shift ${#ids[@]}; ;;
      -model)              optarg  model      $1 "$2"; shift; ;;
      -hdrdofs)            optarg  hdrdofs    $1 "$2"; shift; ;;
      -dofins)             optarg  dofins     $1 "$2"; shift; ;;
      -dofdir)             optarg  dofdir     $1 "$2"; shift; ;;
      -par)                optarg  param      $1 "$2"; shift; params="$params\n$param"; ;;
      -similarity)         optarg  similarity $1 "$2"; shift; ;;
      -bgvalue|-padding)   optarg  padding    $1 "$2"; shift; ;;
      -inverse-consistent) energy='0.5 SIM[Forward similarity](I1, I2 o T) + 0.5 SIM[Backward similarity](I1 o T^-1, I2)'; ;;
      -symmetric)          energy='SIM[Similarity](I1 o T^-0.5, I2 o T^0.5)'; ;;
      -*)                  error "ireg_node: invalid option: $1"; ;;
      *)                   [ -z "$node" ] || error "ireg_node: too many arguments"
                           node=$1; ;;
    esac
    shift
  done
  [ -n "$node"       ] || error "ireg_node: missing name argument"
  [ -n "$model"      ] || error "ireg_node: missing -model argument"
  [ ${#ids[@]} -ge 2 ] || error "ireg_node: not enough -subjects specified"

  local par="Transformation model             = $model"
  par="$par\nEnergy function                  = $energy"
  par="$par\nSimilarity measure               = $similarity"
  par="$par\nPadding value                    = $padding"
  par="$par\nMaximum streak of rejected steps = 3"
  par="$par\nStrict step length range         = No"
  par="$par\n$params"
  parin="$_dagdir/$node.par"
  write "$parin" "$par\n"

  info "Adding ireg node $node..."
  local pre=
  local sub=
  local n=0
  begin_dag $node
  for id1 in "${ids[@]}"; do
    let n++
    pre="$pre\nmkdir -p '$_dagdir/ireg_$id1.log' || exit 1"
    [ -z "$dofdir" ] || pre="$pre\nmkdir -p '$dofdir/$id1' || exit 1"
    for id2 in "${ids[@]}"; do
      [[ $id1 != $id2 ]] || continue
      sub="$sub\n\n# target: $id1, source: $id2"
      sub="$sub\narguments = \""
      if [ -n "$hdrdofs" ]; then
        sub="$sub -image '$imgdir/$id1.nii.gz' -dof '$hdrdofs/$id1.dof.gz'"
        sub="$sub -image '$imgdir/$id2.nii.gz' -dof '$hdrdofs/$id2.dof.gz'"
      else
        sub="$sub -image '$imgdir/$id1.nii.gz' -image '$imgdir/$id2.nii.gz'"
      fi
      sub="$sub -v"
      [ -z "$dofins" ] || sub="$sub -dofin  '$dofins/$id1/$id2.dof.gz'"
      [ -z "$dofdir" ] || sub="$sub -dofout '$dofdir/$id1/$id2.dof.gz'"
      sub="$sub -parin '$parin' -parout '$_dagdir/ireg_$id1.log/ireg_$id1,$id2.par'"
      sub="$sub\""
      sub="$sub\noutput    = $_dagdir/ireg_$id1.log/ireg_$id1,$id2.out"
      sub="$sub\nerror     = $_dagdir/ireg_$id1.log/ireg_$id1,$id2.err"
      sub="$sub\nqueue"
    done
    add_node ireg_$id1 ireg
    info "  Added subnode `printf '%3d of %d' $n ${#ids[@]}`"
  done
  end_dag
  add_edge $node ${parent[@]}
  info "Adding ireg node $node... done"
}

# ------------------------------------------------------------------------------
# add node for averaging of transformations
dofaverage_node()
{
  local node=
  local parent=()
  local ids=()
  local doflst=
  local dofins=
  local dofdir=
  local options=''

  while [ $# -gt 0 ]; do
    case "$1" in
      -parent)   optargs parent "$@"; shift ${#parent[@]}; ;;
      -subjects) optargs ids    "$@"; shift ${#ids[@]}; ;;
      -doflst)   optarg  doflst $1 "$2"; shift; ;;
      -dofins)   optarg  dofins $1 "$2"; shift; ;;
      -dofdir)   optarg  dofdir $1 "$2"; shift; ;;
      -norigid)  options="$options -norigid";  ;;
      -dofs)     options="$options -dofs"; ;;
      -*)        error "dofaverage_node: invalid option: $1"; ;;
      *)         [ -z "$node" ] || error "Too many arguments"
                 node=$1; ;;
    esac
    shift
  done
  [ -n "$node"   ] || error "dofaverage_node: missing name argument"
  [ -n "$dofins" ] || error "dofaverage_node: missing -dofins argument"

  if [ -z "$doflst" ]; then
    local dofnames=
    for id in "${ids[@]}"; do
      dofnames="$dofnames$id\t1\n"
    done
    doflst="$_dagdir/$node.par"
    write "$doflst" "$dofnames"
  fi

  info "Adding dofaverage node $node..."
  local pre=''
  local sub=''
  pre="$pre\nmkdir -p '$_dagdir/$node.log' || exit 1"
  [ -z "$dofdir" ] || pre="$pre\nmkdir -p '$dofdir' || exit 1"
  for id in "${ids[@]}"; do
    sub="$sub\n\n# subject: $id"
    sub="$sub\narguments = \"'$dofdir/$id.dof.gz' -all$options -add-identity-for-dofname '$id'"
    sub="$sub -dofdir '$dofins' -dofnames '$doflst' -prefix '$id/' -suffix .dof.gz"
    sub="$sub\""
    sub="$sub\noutput    = $_dagdir/$node.log/dofaverage_$id.out"
    sub="$sub\nerror     = $_dagdir/$node.log/dofaverage_$id.err"
    sub="$sub\nqueue"
  done
  add_node $node dofaverage
  add_edge $node ${parent[@]}
  info "Adding dofaverage node $node... done"
}

# ------------------------------------------------------------------------------
# add node for composition of transformations
dofcombine_node()
{
  local node=
  local parent=()
  local ids=()
  local dofdir1=
  local dofdir2=
  local dofdir3=
  local options=

  while [ $# -gt 0 ]; do
    case "$1" in
      -parent)   optargs parent "$@"; shift ${#parent[@]}; ;;
      -subjects) optargs ids    "$@"; shift ${#ids[@]}; ;;
      -dofdir1)  optarg  dofdir1 $1 "$2"; shift; ;;
      -dofdir2)  optarg  dofdir2 $1 "$2"; shift; ;;
      -dofdir3)  optarg  dofdir3 $1 "$2"; shift; ;;
      -invert1)  options="$options -invert1";  ;;
      -invert2)  options="$options -invert2"; ;;
      -*)        error "dofcombine_node: invalid option: $1"; ;;
      *)         [ -z "$node" ] || error "dofcombine_node: too many arguments"
                 node=$1; ;;
    esac
    shift
  done
  [ -n "$node"    ] || error "dofcombine_node: missing name argument"
  [ -n "$dofdir1" ] || error "dofcombine_node: missing -dofdir1 argument"
  [ -n "$dofdir2" ] || error "dofcombine_node: missing -dofdir2 argument"
  [ -n "$dofdir3" ] || error "dofcombine_node: missing -dofdir3 argument"

  info "Adding dofcombine node $node..."
  local pre=''
  local sub=''
  pre="$pre\nmkdir -p '$_dagdir/$node.log' || exit 1"
  pre="$pre\nmkdir -p '$dofdir3' || exit 1"
  for id in "${ids[@]}"; do
    sub="$sub\n\n# subject: $id"
    sub="$sub\narguments = \"'$dofdir1/$id.dof.gz' '$dofdir2/$id.dof.gz' '$dofdir3/$id.dof.gz'$options\""
    sub="$sub\noutput    = $_dagdir/$node.log/dofcombine_$id.out"
    sub="$sub\nerror     = $_dagdir/$node.log/dofcombine_$id.err"
    sub="$sub\nqueue"
  done
  add_node $node dofcombine
  add_edge $node ${parent[@]}
  info "Adding dofcombine node $node... done"
}
