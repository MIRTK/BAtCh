#! /bin/bash

appid="$(basename "$0")"
appdir="$(cd "$(dirname "$BASH_SOURCE")" && pwd)"
appdir="$(cd "$appdir/.." && pwd)"

source "$appdir/lib/daggen/mirtk.sh" || {
  echo "Failed to import daggen/mirtk module!" 1>&2
  exit 1
}
source "$appdir/etc/config/default.sh" || {
  error "Failed to load default configuration"
}

# ==============================================================================
# help
# ==============================================================================

# ------------------------------------------------------------------------------
print_help()
{
  cat <<HELP

usage: $appid [options]

This script generates the DAGMan worflow description for the generation
of a consistent brain atlas and growth model for submission to the batch
queuing system HTCondor for distributed parallel execution. Alternatively,
the workflow can be executed sequentially on the local machine or submitted
to another supported batch queuing system (e.g., SLURM).

Options:
  -c, -config <config.sh>
      Custom configuration file. (default: none)
  -a, -agelst <age.csv>
      Comma/space-separated CSV file, where the first column contains
      the image ID and the second column the associated age.
      (default: $agelst)
  -s, -sublst <sub.lst>
      Text file listing the IDs of the images to use for the atlas construction.
      If not specified, the IDs are read from the -agelst.
      (default: $sublst)
  -u, -update
      Overwrite existing DAGMan files.
  -h, -help
      Print help and exit.
  -v, -verbose
      Enable verbose output messages.
HELP
}

# ==============================================================================
# configuration
# ==============================================================================

o=0
while [ $o -lt $# ]; do
  case "${!o}" in
    -c|-config)
      let a=o+1; optarg config ${!o} "${!a}";
      source "$config" || {
        error "Failed to load configuration from file: $config"
      }
      ;;
  esac
  let o++
done

[ -z "$agelst" ] || agelst="$topdir/$agelst"
[ -z "$sublst" ] || sublst="$topdir/$sublst"

while [ $# -gt 0 ]; do
  case "$1" in
    -s|-sublst) optarg sublst $1 "$2"; shift; ;;
    -a|-agelst) optarg agelst $1 "$2"; shift; ;;
    -u|-update) update='true'; ;;
    -c|-config) shift; ;; # already loaded
    -h|-help|--help) print_help; exit 0; ;;
    -v|-verbose) let verbose++; ;;
    *) error "Unknown argument: $1"; ;;
  esac
  shift
done

if [ -z "$agelst" ] || [ ! -f "$agelst" ]; then
  error "Missing CSV file with subject IDs and corresponding ages!"
fi
[ -n "$sublst" ] || sublst="$agelst"
read_sublst subids "$sublst"

cd "$topdir" || error "Failed to change to working directory!"

# atlas time points for which kernel was create either manually,
# with another tool (e.g. MATLAB), or using the "kernel" shell script
timepoints=($(ls "$kernel/" | awk '{
  if ($0 ~ /t[0-9]+(.[0-9]+)?.csv/) {
    print gensub(/t([0-9.]+(.[0-9]+)?).csv/, "\\1", "g")
  }
}'))
if [ ${#timepoints} -eq 0 ]; then
  error "No regression kernels matching pattern \"t([0-9.]+(.[0-9]+)?).csv\" found in $kernel directory!"
fi

# ==============================================================================
# workflow
# ==============================================================================

begin_dag 'brainatlas' -dagfile "$dagdir/main.dag" -dagdir "$dagdir"

  # ----------------------------------------------------------------------------
  # global normalization (translation, rotation, and scale)
  begin_dag 'aff_alignment' -splice

    if [[ $refini == false ]] && [ -n "$refid" ]; then

      # initialize transformations
      register_node 'align' \
          -subjects "${subids[@]}" \
          -srcid    "$refid" \
          -srcdir   "$refdir" \
          -srcpre   "$refpre" \
          -srcsuf   "$refsuf" \
          -imgdir   "$imgdir" \
          -imgpre   "$imgpre" \
          -imgsuf   "$imgsuf" \
          -dofdir   "$dofdir/1.1_ini" \
          -model    "Similarity" \
          -sim      "$similarity" \
          -bgvalue  "$bgvalue" \
          -maxres   $resolution \
          -segdir   "$segdir" \
          -segmsk   'BS+CB' .33 \
          -levels   4 2

      # affine registration
      register_node 'regref' -parent 'align' \
          -subjects "${subids[@]}" \
          -srcid    "$refid" \
          -srcdir   "$refdir" \
          -srcpre   "$refpre" \
          -srcsuf   "$refsuf" \
          -imgdir   "$imgdir" \
          -imgpre   "$imgpre" \
          -imgsuf   "$imgsuf" \
          -dofins   "$dofdir/1.1_ini" \
          -dofdir   "$dofdir/1.2_ref" \
          -model    "Affine" \
          -par      "Allow shearing" No \
          -sim      "$similarity" \
          -padding  "$bgvalue" \
          -maxres   $resolution \
          -levels   3 1

      # global normalization output
      nrmdofs="$dofdir/1.2_ref"

    else

      # initialize pairwise transformations
      register_node 'initdofs' \
          -subjects "${subids[@]}" \
          -imgdir   "$imgdir" \
          -imgpre   "$imgpre" \
          -imgsuf   "$imgsuf" \
          -dofdir   "$dofdir/1.1_sim" \
          -model    "Similarity" \
          -sim      "$similarity" \
          -bgvalue  "$bgvalue" \
          -maxres   $resolution \
          -segdir   "$segdir" \
          -segmsk   'BS+CB' .33 \
          -levels   4 2 \
          -group    20

      # pairwise affine registration
      register_node 'regaff' -parent 'initdofs' \
          -subjects "${subids[@]}" \
          -imgdir   "$imgdir" \
          -imgpre   "$imgpre" \
          -imgsuf   "$imgsuf" \
          -dofins   "$dofdir/1.1_sim" \
          -dofdir   "$dofdir/1.2_aff" \
          -model    "Affine" \
          -par      "Allow shearing" No \
          -sim      "$similarity" \
          -padding  "$bgvalue" \
          -maxres   $resolution \
          -levels   3 1 \
          -group    20

      # average pairwise transformations
      average_dofs_node 'avgdofs' -parent 'regaff' \
          -subjects "${subids[@]}" \
          -dofins   "$dofdir/1.2_aff" \
          -dofdir   "$dofdir/1.3_avg" \
          -noshearing

      # pairwise affine refinement
      register_node 'refine' -parent 'avgdofs' \
          -subjects "${subids[@]}" \
          -imgdir   "$imgdir" \
          -imgpre   "$imgpre" \
          -imgsuf   "$imgsuf" \
          -hdrdofs  "$dofdir/1.3_avg" \
          -dofins   'identity' \
          -dofdir   "$dofdir/1.4_res" \
          -model    "Affine" \
          -par      "Allow shearing" No \
          -sim      "$similarity" \
          -padding  "$bgvalue" \
          -maxres   $resolution \
          -levels   2 \
          -group    20

      # average pairwise transformations
      average_dofs_node 'avgres' -parent 'refine' \
          -subjects "${subids[@]}" \
          -dofins   "$dofdir/1.4_res" \
          -dofdir   "$dofdir/1.5_avg" \
          -noshearing

      # compose average transformations
      compose_dofs_node 'compose' -parent 'avgres' \
          -subjects "${subids[@]}" \
          -dofin1   "$dofdir/1.3_avg" \
          -dofin2   "$dofdir/1.5_avg" \
          -dofdir   "$dofdir/1.6_aff" \
          -noshearing

      # global normalization output
      nrmdofs="$dofdir/1.6_aff"

    fi

  end_dag

  # ----------------------------------------------------------------------------
  # generate population specific reference image/mask
  nrmdir="$outdir/average/t2w"
  nrmref='linear'
  nrmpre=''
  nrmsuf='.nii.gz'

  if [[ $refini == false ]]; then
    linref="$refid"
  else
    linref=
    [ -z "$refid" ] || nrmdir="$tmpdir"
  fi

  average_images_node 'make_average' -parent 'aff_alignment' \
      -subjects "${subids[@]}" \
      -refdir   "$refdir" \
      -refpre   "$refpre" \
      -refid    "$linref" \
      -refsuf   "$refsuf" \
      -imgdir   "$imgdir" \
      -imgpre   "$imgpre" \
      -imgsuf   "$imgsuf" \
      -dofdir   "$nrmdofs" \
      -output   "$nrmdir/$nrmref$nrmsuf" \
      -spacing  $resolution \
      -padding  "$bgvalue" \
      -margin   5

  prev_node='make_average'

  # ----------------------------------------------------------------------------
  # align images to user supplied input reference
  if [[ ! $refini == false ]] && [ -n "$refid" ]; then

    begin_dag 'ref_alignment' -parent "$prev_node" -splice

      # register user reference to constructed affine reference
      register_node 'reg_average' \
          -model   "Rigid" \
          -tgtdir  "$nrmdir" \
          -tgtid   "$nrmref" \
          -tgtpre  "$nrmpre" \
          -tgtsuf  "$nrmsuf" \
          -srcdir  "$refdir" \
          -srcid   "$refid" \
          -srcpre  "$refpre" \
          -srcsuf  "$refsuf" \
          -padding "$bgvalue" \
          -dofdir  "$tmpdir" \
          -dofid   "$nrmref"

      # transform linear average image to user reference space
      transform_image_node 'map_average' -parent 'reg_average' \
          -srcid    "$nrmref" \
          -srcdir   "$nrmdir" \
          -srcpre   "$nrmpre" \
          -srcsuf   "$nrmsuf" \
          -tgtdir   "$refdir" \
          -tgtid    "$refid" \
          -tgtpre   "$refpre" \
          -tgtsuf   "$refsuf" \
          -spacing  $resolution \
          -padding  "$bgvalue" \
          -dofins   "$tmpdir" -invert \
          -outdir   "$outdir/average/t2w" \
          -outid    "$nrmref" \
          -outpre   "$nrmpre" \
          -outsuf   "$nrmsuf"

      # compose affine transformations: image --> auto-ref --> user-ref
      compose_dofs_node 'compose_dofs' -parent 'reg_average' \
          -subjects "${subids[@]}" \
          -dofin1   "$nrmdofs" \
          -dofin2   "$tmpdir" -dofid2 "$nrmref" \
          -dofdir   "$dofdir/1.7_ref" \
          -noshearing

    end_dag

    # use user supplied reference space for non-rigid atlas construction
    prev_node='ref_alignment'
    nrmdofs="$dofdir/1.7_ref"
    nrmdir="$outdir/average/t2w"

  fi

  # ----------------------------------------------------------------------------
  # compute cross-sectional FFDs for each time point between each pair of images
  #
  # TODO: Use only subset of images for this stage when iterative template
  #       refinement is used in the next stage, i.e., use only first n images
  #       of each temporal kernel, merge, and remove duplicates.
  begin_dag 'def_alignment' -parent "$prev_node" -splice

    # deformable registration of all pairs of images after global normalization
    register_node 'reg_pairwise' \
        -subjects "${subids[@]}" \
        -imgdir   "$imgdir" \
        -imgpre   "$imgpre" \
        -imgsuf   "$imgsuf" \
        -model    "SVFFD" \
        -mffd     "None" \
        -spacing  $spacing \
        -bending  $bending \
        -jacobian $jacobian \
        -sim      "$similarity" \
        -padding  "$bgvalue" \
        -hdrdofs  "$nrmdofs" \
        -dofins   "identity" \
        -dofdir   "$dofdir/2.1_def" \
        -domain   "$nrmdir/$nrmpre$nrmref$nrmsuf" \
        -maxres   $resolution \
        -levels   4 \
        -symmetric

    # compute average deformations for each subject and atlas time point
    defdofs="$dofdir/2.2_avg"
    for t in ${timepoints[@]}; do

      average_dofs_node "avg_ffds_$t" -parent 'reg_pairwise' \
          -doflst "$kernel/t$t.csv" \
          -dofins "$dofdir/2.1_def" \
          -dofdir "$defdofs/t$t" \
          -dofs

    done

  end_dag

  prev_node='def_alignment'

  # ----------------------------------------------------------------------------
  # optional iterative refinement of local deformations
  #
  # 1. Update average image without global average scale
  # 2. Register average to each image
  # 3. Repeat steps 1 and 2 a number of times
  #    (TODO: or until average image barely changes)
  if [ -n "$refine" ] && [ $refine -gt 0 ]; then
    begin_dag 'def_refinement' -parent "$prev_node" -splice

      prev_node=''

      i=1
      while [ $i -le $refine ]; do

        let j="$i + 1"
        nxtdofs="$dofdir/2.${j}_def"

        # update average images
        begin_dag "make_templates_$i" -parent "$prev_node" -splice
          for t in ${timepoints[@]}; do

            average_images_node "average_$t" \
                -sublst "$kernel/t$t.csv" \
                -imgdir "$imgdir" \
                -imgpre "$imgpre" \
                -imgsuf '.nii.gz' \
                -refid  "$nrmref" \
                -refdir "$nrmdir" \
                -refpre "$nrmpre" \
                -refsuf "$nrmsuf" \
                -dofin1 "$nrmdofs" \
                -dofin2 "$defdofs/t$t" \
                -output "$tmpdir/t2w_$t-$i.nii.gz"

          done
        end_dag       

        # register average images to each subject (after global normalization)
        begin_dag "reg_templates_$i" -parent "make_templates_$i" -splice
          for t in ${timepoints[@]}; do

            register_node "refine_$t" \
                -sublst   "$kernel/t$t.csv" \
                -imgdir   "$imgdir" \
                -imgpre   "$imgpre" \
                -imgsuf   "$imgsuf" \
                -srcdir   "$tmpdir" \
                -srcid    "t2w_$t-$i" \
                -srcsuf   ".nii.gz" \
                -model    "SVFFD" \
                -mffd     "None" \
                -spacing  $spacing \
                -bending  $bending \
                -jacobian $jacobian \
                -sim      "$similarity" \
                -padding  "$bgvalue" \
                -hdrdofs  "$nrmdofs" \
                -dofins   "identity" \
                -dofdir   "$nxtdofs/t$t" \
                -domain   "$nrmdir/$nrmpre$nrmref$nrmsuf" \
                -maxres   $resolution

          done
        end_dag

        prev_node="reg_templates_$i"
        defdofs="$nxtdofs"

        let i++
      done

    end_dag

    unset -v i nxtdofs
    prev_node='def_refinement'
  fi

  # ----------------------------------------------------------------------------
  # average global scaling (i.e. brain size relative to reference)
  begin_dag 'make_dofs' -parent "$prev_node" -splice
    for t in ${timepoints[@]}; do

      average_dofs_node "avgdof_$t" \
          -doflst "$kernel/t$t.csv" \
          -dofins "$nrmdofs" \
          -dofdir "$outdir/dofs" \
          -dofid  "t$t" -outsuf ".dof" \
          -invert -norigid -noshearing

    done
  end_dag

  # ----------------------------------------------------------------------------
  # make template images
  begin_dag 'make_templates' -parent "$prev_node" -splice
    for t in ${timepoints[@]}; do

      average_images_node "average_$t" \
          -sublst "$kernel/t$t.csv" \
          -imgdir "$imgdir" \
          -imgpre "$imgpre" \
          -imgsuf '.nii.gz' \
          -refid  "$nrmref" \
          -refdir "$nrmdir" \
          -refpre "$nrmpre" \
          -refsuf "$nrmsuf" \
          -dofin1 "$nrmdofs" \
          -dofin2 "$defdofs/t$t" \
          -output "$outdir/average/t2w/t$t.nii.gz"

      edit_image_node "putdof_$t" \
          -imgdir "$outdir/average/t2w" \
          -imgid  "t$t" \
          -imgsuf ".nii.gz" \
          -outdir "$outdir/templates/t2w" \
          -dofins "$outdir/dofs" \
          -dofid  "t$t" \
          -dofsuf ".dof"

    done
  end_dag

  # ----------------------------------------------------------------------------
  # make tissue probability maps
  if [ -n "$lbldir" ]; then
    inpdir="$(dirname  "$lbldir/${clspre}id")"
    prefix="$(basename "$lbldir/${clspre}id")"
    prefix="${prefix:0:${#prefix}-2}"
    if [ -d "$inpdir" ] && [ $(find -L "$inpdir" -name "$prefix*$lblsuf" | wc -l) -gt 0 ]; then
      begin_dag 'make_tissue_pbmaps' -parent "$prev_node" -splice

        for t in ${timepoints[@]}; do
          l=1
          while [ $l -le $tissues ]; do

            average_images_node "make_tissue_pbmaps_${l}_${t}" \
                -sublst "$kernel/t$t.csv" \
                -imgdir "$inpdir" \
                -imgpre "$prefix" \
                -imgsuf "$clssuf" \
                -refid  "$nrmref" \
                -refdir "$nrmdir" \
                -refpre "$nrmpre" \
                -refsuf "$nrmsuf" \
                -dofin1 "$nrmdofs" \
                -dofin2 "$defdofs/t$t" \
                -output "$outdir/pbmaps/t$t/tissue_$l.nii.gz" \
                -label $l
     
            let l++
          done
        done

      end_dag
    fi
  fi

  # ----------------------------------------------------------------------------
  # make structural probability maps
  if [ -n "$lbldir" ]; then
    inpdir="$(dirname  "$lbldir/${lblpre}id")"
    prefix="$(basename "$lbldir/${lblpre}id")"
    prefix="${prefix:0:${#prefix}-2}"
    if [ -d "$inpdir" ] && [ $(find -L "$inpdir" -name "$prefix*$lblsuf" | wc -l) -gt 0 ]; then
      begin_dag 'make_structural_pbmaps' -parent "$prev_node" -splice

        for t in ${timepoints[@]}; do
          l=1
          while [ $l -le $structures ]; do

            average_images_node "make_structural_pbmaps_${l}_${t}" \
                -sublst "$kernel/t$t.csv" \
                -imgdir "$inpdir" \
                -imgpre "$prefix" \
                -imgsuf "$lblsuf" \
                -refid  "$nrmref" \
                -refdir "$nrmdir" \
                -refpre "$nrmpre" \
                -refsuf "$nrmsuf" \
                -dofin1 "$nrmdofs" \
                -dofin2 "$defdofs/t$t" \
                -output "$outdir/pbmaps/t$t/structure_$l.nii.gz" \
                -label $l
     
            let l++
          done
        done

      end_dag
    fi
  fi

  # ----------------------------------------------------------------------------
  # construct longitudinal growth model
  #begin_dag 'growth' -parent 'avgffds' -splice
    # TODO
  #end_dag
 
end_dag
